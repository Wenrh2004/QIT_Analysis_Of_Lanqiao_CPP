# Reverse linked list

## Description
在一个链表中每三个节点为一组将每一组的两边节点进行交换，不足一组的节点不进行交换

---

## Input
输入一行数字表示链表以-1表示结束中间用空格隔开

---

## Output
输出交换后的链表中间用空格隔开

---

## Sample Input and Output
|     | Sample Input | Sample Output |
|-----|--------------|---------------|
| 1st | 1 2 3 4 5 -1 | 3 2 1 4 5     |

---

## Analysis
挺水的一道题，为了增加点难度，我们就按照题目描述的链表来做，同时尽可能保证工程规范和代码安全。  

**思路** 
- **工程化**
  - 数据读取
    - 逐个写入，遇到`-1`停止
  - 排序
    - **need**
      - 反转链表
    - **做法**
      - 存入链表
      - 链表节点的值放入容器
      - 容器中交换索引
        - 题目中三个为一组进行交换，则可以通过`for`循环迭代来实现
        - 迭代间隔为`3`，迭代范围`i + 2 < vector.size()`(防止数组越界:`i+2`为单个组内最右侧的元素，保证不越界的前提即为保证每一组最右侧的值不越界，即`i + 2 < vector.size()`
        - ```c++
            for (int i = 0; i + 2 < vector.size(); i += 3) {
                // your code for warp
            }
          ```
      - 覆盖之前链表(减小内存开销)
- **算竞**
  - 数据读取
    - 存入容器或数组
  - 排序
    - 交换索引

---

## [Example](./reverse_linked_list.cpp)
> *该样例为工程化样例，根据此样例可以非常方便的完成算竞样例，因此不再单独提供样例*
 
## [Explainer video]()